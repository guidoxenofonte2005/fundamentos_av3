<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[RESUMOS QUARTO SEMESTRE]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib\media\favicon.png</url><title>RESUMOS QUARTO SEMESTRE</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Thu, 15 May 2025 00:06:37 GMT</lastBuildDate><atom:link href="lib\rss.xml" rel="self" type="application/rss+xml"/><pubDate>Thu, 15 May 2025 00:06:29 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[Aplicações Científicas]]></title><description><![CDATA[<a class="tag" href="?query=tag:FORTRAN" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#FORTRAN</a> <a class="tag" href="?query=tag:ALGOL60" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#ALGOL60</a> 
 <br><a href=".?query=tag:FORTRAN" class="tag" target="_blank" rel="noopener nofollow">#FORTRAN</a> <a href=".?query=tag:ALGOL60" class="tag" target="_blank" rel="noopener nofollow">#ALGOL60</a>]]></description><link>fundamentos-de-linguagens-de-programação\av1\conceitos-preliminares\aplicações\aplicações-científicas.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Conceitos Preliminares/Aplicações/Aplicações Científicas.md</guid><pubDate>Fri, 28 Mar 2025 01:55:40 GMT</pubDate></item><item><title><![CDATA[Aplicações de Negócios]]></title><description><![CDATA[<a class="tag" href="?query=tag:COBOL" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#COBOL</a> 
 <br><a href=".?query=tag:COBOL" class="tag" target="_blank" rel="noopener nofollow">#COBOL</a>]]></description><link>fundamentos-de-linguagens-de-programação\av1\conceitos-preliminares\aplicações\aplicações-de-negócios.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Conceitos Preliminares/Aplicações/Aplicações de Negócios.md</guid><pubDate>Fri, 28 Mar 2025 01:55:40 GMT</pubDate></item><item><title><![CDATA[Aplicações em Inteligência Artificial]]></title><description><![CDATA[<a class="tag" href="?query=tag:LISP" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#LISP</a> <a class="tag" href="?query=tag:PROLOG" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#PROLOG</a> 
 <br><a href=".?query=tag:LISP" class="tag" target="_blank" rel="noopener nofollow">#LISP</a> <a href=".?query=tag:PROLOG" class="tag" target="_blank" rel="noopener nofollow">#PROLOG</a>]]></description><link>fundamentos-de-linguagens-de-programação\av1\conceitos-preliminares\aplicações\aplicações-em-inteligência-artificial.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Conceitos Preliminares/Aplicações/Aplicações em Inteligência Artificial.md</guid><pubDate>Fri, 28 Mar 2025 01:55:40 GMT</pubDate></item><item><title><![CDATA[Aplicações em Sistemas Operacionais]]></title><description><![CDATA[<a class="tag" href="?query=tag:C" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#C</a> <a class="tag" href="?query=tag:CPP" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#CPP</a> 
 <br><a href=".?query=tag:C" class="tag" target="_blank" rel="noopener nofollow">#C</a> <a href=".?query=tag:CPP" class="tag" target="_blank" rel="noopener nofollow">#CPP</a> ]]></description><link>fundamentos-de-linguagens-de-programação\av1\conceitos-preliminares\aplicações\aplicações-em-sistemas-operacionais.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Conceitos Preliminares/Aplicações/Aplicações em Sistemas Operacionais.md</guid><pubDate>Fri, 28 Mar 2025 01:55:40 GMT</pubDate></item><item><title><![CDATA[Aplicações WEB]]></title><description><![CDATA[<a class="tag" href="?query=tag:HTML" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#HTML</a> <a class="tag" href="?query=tag:Java" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Java</a> <a class="tag" href="?query=tag:Python" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Python</a> <a class="tag" href="?query=tag:JavaScript" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#JavaScript</a> <a class="tag" href="?query=tag:PHP" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#PHP</a> 
 <br><a href=".?query=tag:HTML" class="tag" target="_blank" rel="noopener nofollow">#HTML</a> <a href=".?query=tag:Java" class="tag" target="_blank" rel="noopener nofollow">#Java</a> <a href=".?query=tag:Python" class="tag" target="_blank" rel="noopener nofollow">#Python</a> <a href=".?query=tag:JavaScript" class="tag" target="_blank" rel="noopener nofollow">#JavaScript</a> <a href=".?query=tag:PHP" class="tag" target="_blank" rel="noopener nofollow">#PHP</a>]]></description><link>fundamentos-de-linguagens-de-programação\av1\conceitos-preliminares\aplicações\aplicações-web.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Conceitos Preliminares/Aplicações/Aplicações WEB.md</guid><pubDate>Fri, 28 Mar 2025 01:55:40 GMT</pubDate></item><item><title><![CDATA[Áreas de Aplicação]]></title><description><![CDATA[ 
 <br><br>
<br>Os primeiros computadores digitais foram inventados com propósitos científicos
<br>Preocupação maior com eficiência
<br>Linguagens: FORTRAN, ALGOL 60
<br><br>
<br>Início na década de 50
<br>Linguagens: COBOL
<br><br>
<br>Possui vastas aplicações
<br>Boa parte das aplicações antes de 1990 eram escritas em LISP ou alguma linguagem relativa
<br>A partir de 1970, começaram a surgir aplicações que utilizavam programação lógica, adotando a linguagem PROLOG
<br><br>
<br>Necessidade de eficiência
<br>Boa parte são escritos em C ou C++ atualmente
<br>Maior parte do UNIX é desenvolvida em C
<br><br>
<br>Utilizado no desenvolvimento de aplicações para internet
<br>Linguagens: HTML, CSS, Java, JavaScript, Python, PHP
]]></description><link>fundamentos-de-linguagens-de-programação\av1\conceitos-preliminares\aplicações\áreas-de-aplicação.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Conceitos Preliminares/Aplicações/Áreas de Aplicação.md</guid><pubDate>Fri, 28 Mar 2025 01:55:40 GMT</pubDate></item><item><title><![CDATA[Avaliação de uma Linguagem]]></title><description><![CDATA[ 
 <br><br>]]></description><link>fundamentos-de-linguagens-de-programação\av1\conceitos-preliminares\avaliação\avaliação-de-uma-linguagem.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Conceitos Preliminares/Avaliação/Avaliação de uma Linguagem.md</guid><pubDate>Fri, 28 Mar 2025 01:55:40 GMT</pubDate></item><item><title><![CDATA[Características Associadas a Critérios]]></title><description><![CDATA[ 
 <br><br>
<br>Afeta fortemente a legibilidade e a facilidade de escrita
<br>Uma linguagem com muitas construções básicas é mais difícil de aprender
<br>A simplicidade extrema pode tornar os programas menos legíveis (ex.: Assembly)
<br><br>
<br>Significa que um conjunto relativamente pequeno de construções primitivas pode ser combinado a um número relativamente pequeno de formas para construir as estruturas de controle e os dados da linguagem
<br>Uma falta de ortogonalidade leva a exceções às regras de linguagem
<br><br>
<br>Presença de mecanismos adequados para definir tipos e estruturas de dados
<br>Influente na facilidade de escrita e legibilidade
<br><br>
<br>Forma de expressões, sentenças e unidades de programas
<br>Definição do formato de identificadores
<br>Definição de palavras especiais
<br><br>
<br>Habilidade de definir e usar estruturas/operações complexas de forma a permitir que muitos dos detalhes sejam ignorados
<br><br>
<br>Pode se referir a várias características
<br>Em geral, uma linguagem expressiva especifica computações de forma conveniente, podendo permitir diferentes notações para uma mesma operação
<br>Influencia a facilidade de escrita de uma linguagem
<br><br>
<br>Execução de testes para detectar erros de tipos em um programa, seja no momento de compilação ou durante a execução de um programa
<br>Fator importante na confiabilidade de uma linguagem
<br>Quanto mais cedo os erros forem detectados, menos caro é consertá-los
<br><br>
<br>Possibilita que um programa intercepte erros em tempo de execução (e outras condições não usuais) e tome medidas corretivas
<br>Característica importante para a confiabilidade da linguagem
<br><br>
<br>Permitidos quando é possível utilizar um ou mais nomes para acessar a mesma célula de memória
<br>Em algumas linguagens, são usados para resolver deficiências na abstração dos dados
<br>Outras linguagens restringem o uso de apelidos visando aumento de confiabilidade
]]></description><link>fundamentos-de-linguagens-de-programação\av1\conceitos-preliminares\avaliação\características-associadas-a-critérios.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Conceitos Preliminares/Avaliação/Características Associadas a Critérios.md</guid><pubDate>Fri, 28 Mar 2025 01:55:40 GMT</pubDate></item><item><title><![CDATA[Confiabilidade]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\conceitos-preliminares\avaliação\confiabilidade.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Conceitos Preliminares/Avaliação/Confiabilidade.md</guid><pubDate>Fri, 28 Mar 2025 01:55:40 GMT</pubDate></item><item><title><![CDATA[Critérios de Avaliação]]></title><description><![CDATA[ 
 <br><br>
<br>Facilidade com a qual os programas podem ser lidos e entendidos
<br>Inicialmente, as linguagens se preocupavam mais com eficiência do que com legibilidade
<br>Atualmente, a legibilidade se tornou um fator importante na redução do custo do software
<br><br>
<br>Medida do quão facilmente uma linguagem pode ser utilizada para criar programas
<br>A maioria das características que afetam a legibilidade também afetam a facilidade de escrita
<br><br>
<br>Um programa é dito confiável quando está de acordo com suas especificações em qualquer condição
<br>Linguagens podem ter recursos que tornam os programas gerados por ela confiáveis
<br><br>
<br>Depende de diversos fatores
<br>Custo para treinar programadores, escrever programas na linguagem, compilação, execução, etc.
]]></description><link>fundamentos-de-linguagens-de-programação\av1\conceitos-preliminares\avaliação\critérios-de-avaliação.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Conceitos Preliminares/Avaliação/Critérios de Avaliação.md</guid><pubDate>Fri, 28 Mar 2025 01:55:40 GMT</pubDate></item><item><title><![CDATA[Custo]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\conceitos-preliminares\avaliação\custo.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Conceitos Preliminares/Avaliação/Custo.md</guid><pubDate>Fri, 28 Mar 2025 01:55:40 GMT</pubDate></item><item><title><![CDATA[Expressividade]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\conceitos-preliminares\avaliação\expressividade.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Conceitos Preliminares/Avaliação/Expressividade.md</guid><pubDate>Fri, 28 Mar 2025 01:55:40 GMT</pubDate></item><item><title><![CDATA[Facilidade de Escrita]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\conceitos-preliminares\avaliação\facilidade-de-escrita.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Conceitos Preliminares/Avaliação/Facilidade de Escrita.md</guid><pubDate>Fri, 28 Mar 2025 01:55:40 GMT</pubDate></item><item><title><![CDATA[Legibilidade]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\conceitos-preliminares\avaliação\legibilidade.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Conceitos Preliminares/Avaliação/Legibilidade.md</guid><pubDate>Fri, 28 Mar 2025 01:55:40 GMT</pubDate></item><item><title><![CDATA[Ortogonalidade]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\conceitos-preliminares\avaliação\ortogonalidade.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Conceitos Preliminares/Avaliação/Ortogonalidade.md</guid><pubDate>Fri, 28 Mar 2025 01:55:40 GMT</pubDate></item><item><title><![CDATA[Projeto da Sintaxe]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\conceitos-preliminares\avaliação\projeto-da-sintaxe.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Conceitos Preliminares/Avaliação/Projeto da Sintaxe.md</guid><pubDate>Fri, 28 Mar 2025 01:55:40 GMT</pubDate></item><item><title><![CDATA[Simplicidade Geral]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\conceitos-preliminares\avaliação\simplicidade-geral.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Conceitos Preliminares/Avaliação/Simplicidade Geral.md</guid><pubDate>Fri, 28 Mar 2025 01:55:40 GMT</pubDate></item><item><title><![CDATA[Suporte a Abstração]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\conceitos-preliminares\avaliação\suporte-a-abstração.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Conceitos Preliminares/Avaliação/Suporte a Abstração.md</guid><pubDate>Fri, 28 Mar 2025 01:55:40 GMT</pubDate></item><item><title><![CDATA[Tipo de Dados]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\conceitos-preliminares\avaliação\tipo-de-dados.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Conceitos Preliminares/Avaliação/Tipo de Dados.md</guid><pubDate>Fri, 28 Mar 2025 01:55:40 GMT</pubDate></item><item><title><![CDATA[Tratamentos de Exceção]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\conceitos-preliminares\avaliação\tratamentos-de-exceção.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Conceitos Preliminares/Avaliação/Tratamentos de Exceção.md</guid><pubDate>Fri, 28 Mar 2025 01:55:40 GMT</pubDate></item><item><title><![CDATA[Utilização de Apelidos]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\conceitos-preliminares\avaliação\utilização-de-apelidos.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Conceitos Preliminares/Avaliação/Utilização de Apelidos.md</guid><pubDate>Fri, 28 Mar 2025 01:55:40 GMT</pubDate></item><item><title><![CDATA[Verificação de Tipos]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\conceitos-preliminares\avaliação\verificação-de-tipos.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Conceitos Preliminares/Avaliação/Verificação de Tipos.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Compilação]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\conceitos-preliminares\implementação\compilação.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Conceitos Preliminares/Implementação/Compilação.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Interpretação]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\conceitos-preliminares\implementação\interpretação.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Conceitos Preliminares/Implementação/Interpretação.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Métodos de Implementação de uma Linguagem]]></title><description><![CDATA[ 
 <br><br>
<br>Traduz os programas para linguagem de máquina para que sejam executados diretamente pelo computador
<br>Após o processo de tradução, a execução se torna bastante rápida
<br>O processo de compilação e execução ocorrem em fases diferentes
<br>O analisador léxico agrupa os caracteres da fonte em unidades léxicas (identificadores, palavras especiais, operadores, símbolos de pontuação)
<br>O analisador sintático obtém as unidades léxicas e as utiliza para construir estruturas hierárquicas chamadas de árvores de análise sintática (parse trees) que representam a estrutura sintática do programa
<br>O gerador de código intermediário utiliza a árvore de análise sintática para produzir um programa em uma linguagem diferente (linguagem intermediária)
<br>Finalmente, o gerador de código traduz a versão em código intermediário em um programa equivalente em linguagem de máquina
<br>A otimização é uma parte opcional do processo de compilação e geralmente é realizada com o programa em sua versão em código intermediário
<br><br>
<br>Serve como uma base de dados para o processo de compilação
<br>O conteúdo primário são informações de tipo e atributos para cada um dos nomes definidos pelo usuário
<br>Essa informação é colocada na tabela pelos analisadores léxico e sintático e é usada pelo analisador semântico e pelo gerador de código
<br><br><br>
<br>Os programas são interpretados por outro, chamado interpretador
<br>O interpretador age como uma simulação de uma máquina que utiliza sentenças/comandos de programa de alto nível em vez de instruções de máquina
<br>A interpretação pura tem a vantagem de permitir uma fácil implementação de operações de depuração em código fonte, pois todas as mensagens de erro em tempo de execução podem referenciar unidades de código específicas
<br>Dado que o mesmo programa sempre deve passar pelo processo de interpretação sempre que for executado, programas interpretados tendem a ser mais lentos em comparação a programas compilados
<br><br>
<br>Alguns sistemas de implementação são um meio termo entre compiladores e interpretadores
<br>Nesses casos, eles traduzem os programas em alto nível para uma linguagem intermediária visando facilitar a interpretação
<br>São mais rápidos do que a interpretação pura, pois as sentenças são decodificadas apenas uma vez
<br>Interpretar o código intermediário também é mais rápido que interpretar o código fonte
]]></description><link>fundamentos-de-linguagens-de-programação\av1\conceitos-preliminares\implementação\métodos-de-implementação-de-uma-linguagem.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Conceitos Preliminares/Implementação/Métodos de Implementação de uma Linguagem.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Sistemas Híbridos]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\conceitos-preliminares\implementação\sistemas-híbridos.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Conceitos Preliminares/Implementação/Sistemas Híbridos.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Conceitos Preliminares]]></title><description><![CDATA[ 
 <br><br><br>]]></description><link>fundamentos-de-linguagens-de-programação\av1\conceitos-preliminares\conceitos-preliminares.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Conceitos Preliminares/Conceitos Preliminares.md</guid><pubDate>Fri, 28 Mar 2025 01:55:40 GMT</pubDate></item><item><title><![CDATA[Escopo Dinâmico]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\nvve\escopo\escopo-dinâmico.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/NVVE/Escopo/Escopo Dinâmico.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Escopo Estático]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\nvve\escopo\escopo-estático.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/NVVE/Escopo/Escopo Estático.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Escopos]]></title><description><![CDATA[ 
 <br>
<br>Faixa de sentenças nas quais uma variável é visível
<br>Uma variável é <a data-href="Visível" href="fundamentos-de-linguagens-de-programação\av1\nvve\escopo\visível.html" class="internal-link" target="_self" rel="noopener nofollow">Visível</a> em uma sentença se ela pode ser referenciada na mesma
<br>Uma variável é <a data-href="Local" href="fundamentos-de-linguagens-de-programação\av1\nvve\escopo\local.html" class="internal-link" target="_self" rel="noopener nofollow">Local</a> a uma unidade/bloco de programa se ela for declarada naquela unidade
<br>Uma variável <a data-href="Não Local" href="fundamentos-de-linguagens-de-programação\av1\nvve\escopo\não-local.html" class="internal-link" target="_self" rel="noopener nofollow">Não Local</a> de uma unidade/bloco de programa é uma variável que não foi declarada nesse bloco, mas é visível a ele
<br>Além dos escopos gerados por funções, existem os escopos gerados por blocos, que funcionam de forma semelhante com relação à visibilidade
<br>Diz-se que uma variável faz parte do escopo global quando ela é criada fora do escopo das funções
<br><br>
<br>O escopo das variáveis é determinado antes do tempo de execução do algoritmo
<br><br>
<br>Determinado em tempo de execução
<br>Baseado na sequência de chamadas das funções/procedimentos, e não em seu relacionamento espacial
]]></description><link>fundamentos-de-linguagens-de-programação\av1\nvve\escopo\escopos.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/NVVE/Escopo/Escopos.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Local]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\nvve\escopo\local.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/NVVE/Escopo/Local.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Não Local]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\nvve\escopo\não-local.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/NVVE/Escopo/Não Local.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Visível]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\nvve\escopo\visível.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/NVVE/Escopo/Visível.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Nomes]]></title><description><![CDATA[ 
 <br><br>
<br>Cadeia de caracteres usada para identificar uma entidade no programa
<br>Também chamado de identificador
<br>Cada linguagem descreve um formato para seus nomes, com possíveis regras de capitalização e limitação de caracteres
<br><br>
<br>Usadas para tornar os programas mais legíveis
<br>Nomeiam ações a serem realizadas
<br>Podem (ou não) serem utilizadas como nomes
<br><br>
<br>Palavra especial que não pode ser utilizada como nome
<br>Geralmente as palavras reservadas são mais usadas que as palavras-chave
<br>Podem variar de linguagem para linguagem
]]></description><link>fundamentos-de-linguagens-de-programação\av1\nvve\nomes\nomes.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/NVVE/Nomes/Nomes.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Palavras Especiais]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\nvve\nomes\palavras-especiais.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/NVVE/Nomes/Palavras Especiais.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Palavras Reservadas]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\nvve\nomes\palavras-reservadas.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/NVVE/Nomes/Palavras Reservadas.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Endereço]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\nvve\variaveis\endereço.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/NVVE/Variaveis/Endereço.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Escopo]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\nvve\variaveis\escopo.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/NVVE/Variaveis/Escopo.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Tempo de Vida]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\nvve\variaveis\tempo-de-vida.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/NVVE/Variaveis/Tempo de Vida.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Valor]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\nvve\variaveis\valor.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/NVVE/Variaveis/Valor.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Variáveis]]></title><description><![CDATA[ 
 <br>
<br>Uma variável pode ser caracterizada como um conjunto de seis atributos:
<br><br>
<br>Utilizado para identificar uma entidade/variável
<br><br>
<br>Dado pelo endereço da região de memória associada à variável em questão
<br>Em determinadas situações, uma variável pode ter diferentes endereços
<br>Um endereço pode estar associado a mais de um nome
<br><br>
<br>Determina a faixa de valores que a variável pode assumir
<br><br>
<br>Conteúdo da memória associado à variável em questão
<br><br>]]></description><link>fundamentos-de-linguagens-de-programação\av1\nvve\variaveis\variáveis.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/NVVE/Variaveis/Variáveis.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Vinculação]]></title><description><![CDATA[ 
 <br>
<br>Uma vinculação nada mais é do que uma associação entre valores, como um atributo e uma entidade, uma operação e um símbolo, etc.
<br>Divide-se em dois tipos:
<br><br><br>
<br>Ocorre pela primeira vez antes do tempo de execução do programa e permanece inalterada durante sua execução
<br>Possui dois possíveis tipos de declarações:

<br>Explícitas - Sentenças em um programa que listam nomes de variáveis e especificam os seus tipos
<br>Implícitas - Os tipos são associados a variáveis por meio de convenções


<br>Declarações implícitas podem ser prejudiciais à confiabilidade da linguagem, pois evitam que a linguagem detecte alguns erros em tempo de compilação
<br><br>
<br>A vinculação ocorre quando é atribuído algum valor para a variável
<br>O tipo da variável pode mudar durante a execução do programa
<br>Possui como principal vantagem a flexibilidade do programa
<br>Por outro lado, sua principal desvantagem é permitir com que qualquer valor seja associado a qualquer variável, fazendo com que associações de valores incorretos sejam mais difíceis de serem detectados
<br><br>
<br>Para entender o tempo de vida de uma variável, é necessário entender os seguintes conceitos:

<br>Alocação - Ocorre ao vincular uma variável a um conjunto de células disponíveis na memória
<br>Desalocação - Ocorre quando as células de memória vinculadas a uma variável se tornam disponíveis


<br>O tempo de vida de uma variável se inicia quando ela é alocada e se encerra quando a mesma é desalocada
<br>Variáveis estáticas são vinculadas a células de memória antes da execução do programa e permanecem vinculadas a essas mesmas células até o final da execução
<br>Variáveis dinâmicas na pilha são aquelas cujas vinculações de armazenamento são criadas a partir da elaboração de suas instruções de declaração, mas cujos tipos são estaticamente vinculados
<br>Variáveis dinâmicas no monte explícitas são células de memória sem nome alocadas e desalocadas por instruções explícitas (especificadas pelo programador) em tempo de execução

<br>Só podem ser referenciadas por ponteiros ou variáveis de referência


<br>Variáveis dinâmicas no monte implícitas são vinculadas ao armazenamento no monte apenas quando são atribuídos valores a elas
]]></description><link>fundamentos-de-linguagens-de-programação\av1\nvve\vinculação\vinculação.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/NVVE/Vinculação/Vinculação.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Vinculação de Armazenamento]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\nvve\vinculação\vinculação-de-armazenamento.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/NVVE/Vinculação/Vinculação de Armazenamento.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Vinculação de Tipos]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\nvve\vinculação\vinculação-de-tipos.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/NVVE/Vinculação/Vinculação de Tipos.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Nomes, variáveis, vinculações e escopos]]></title><description><![CDATA[ 
 <br><br>
<br>STACK - Região usada para alocar espaço para variáveis de funções. Quando a função é finalizada, as variáveis correspondentes são desalocadas
<br>HEAP - Região da memória reservada para variáveis alocadas e desalocadas explicitamente pelo programador
<br><br><br><br>]]></description><link>fundamentos-de-linguagens-de-programação\av1\nvve\nomes,-variáveis,-vinculações-e-escopos.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/NVVE/Nomes, variáveis, vinculações e escopos.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Contextualização]]></title><description><![CDATA[ 
 <br><br><br><br>
<br>À medida que uma função é executada, suas variáveis são alocadas na memória stack. Após a execução, as variáveis são desalocadas
<br>É possível alocar variáveis na memória heap
<br>Em algumas linguagens, o desalocamento das variáveis deve ser feito manualmente. Em outras, o desalocamento é automaticamente realizado pelo Garbage Collector
]]></description><link>fundamentos-de-linguagens-de-programação\av1\python\contexto\contextualização.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Python/Contexto/Contextualização.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Memória]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\python\contexto\memória.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Python/Contexto/Memória.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Garbage Collector]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\python\garbage\garbage-collector.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Python/Garbage/Garbage Collector.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Objetos]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\python\memória-e-objetos\objetos.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Python/Memória e Objetos/Objetos.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Stack]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\python\memória-e-objetos\stack.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Python/Memória e Objetos/Stack.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Stack, Heap e Objetos]]></title><description><![CDATA[ 
 <br><br>
<br>Usada para armazenar ponteiros para objetos armazenados na memória heap
<br>Organizada de forma LIFO (Last In, First Out)
<br>Quando uma função é chamada, um novo frame de execução é empilhado na stack
<br>Quando a função termina, o frame é removido
<br>Maior risco - Stack overflow
<br><br>
<br>Usada para armazenar objetos dinâmicos criados em tempo de execução e estruturas de dados complexas
<br>Não é automaticamente desalocada quando uma função termina
<br>Objetos armazenados na memória heap podem ser referenciados por várias partes do código
<br>O garbage collector gerencia automaticamente a desalocação de objetos não utilizados
<br>Mesmo que uma função termine, os objetos ainda continuam existindo na memória heap caso hajam referências externas a eles
<br><br>
<br>Podem ser divididos em dois tipos:

<br>Simples - Inteiros, pontos flutuantes, booleanos, strings
<br>Containers - Listas, dicionários, classes


]]></description><link>fundamentos-de-linguagens-de-programação\av1\python\memória-e-objetos\stack,-heap-e-objetos.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Python/Memória e Objetos/Stack, Heap e Objetos.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Python - Memória e Garbage Collector]]></title><description><![CDATA[ 
 <br><br><br>]]></description><link>fundamentos-de-linguagens-de-programação\av1\python\python-memória-e-garbage-collector.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Python/Python - Memória e Garbage Collector.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[BNF]]></title><description><![CDATA[ 
 <br>
<br>Abreviação para Forma de Backus-Naur, se trata do método de descrição da sintaxe
<br>Backus e Naur introduziram uma notação formal para especificar a sintaxe de linguagens de programação com base na gramática livre de contexto de Chomsky
<br>Se tornou o método mais popular para descrever sintaxe de linguagens de programação de forma concisa
<br><br>
<br>Linguagem utilizada para descrever outra
<br>A BNF é uma metalinguagem para linguagens de programação
<br>Possui os seguintes símbolos:

<br>Conjunto de símbolos terminais
<br>Conjunto de símbolos não-terminais
<br>Símbolo inicial não-terminal


<br><br>
<br>Uma linguagem definida por uma BNF é o conjunto de todas as strings que podem ser derivadas a partir de um símbolo inicial
]]></description><link>fundamentos-de-linguagens-de-programação\av1\sintaxe\bnf\bnf.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Sintaxe/BNF/BNF.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Linguagem]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\sintaxe\bnf\linguagem.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Sintaxe/BNF/Linguagem.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Metalinguagem]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\sintaxe\bnf\metalinguagem.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Sintaxe/BNF/Metalinguagem.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Definição e História]]></title><description><![CDATA[ 
 <br>
<br>O estudo de linguagens pode ser dividido através da <a data-tooltip-position="top" aria-label="AV1/Sintaxe/Definição/Sintaxe" data-href="AV1/Sintaxe/Definição/Sintaxe" href="fundamentos-de-linguagens-de-programação\av1\sintaxe\definição\sintaxe.html" class="internal-link" target="_self" rel="noopener nofollow">Sintaxe</a> e da <a data-href="Semântica" href="fundamentos-de-linguagens-de-programação\av1\sintaxe\definição\semântica.html" class="internal-link" target="_self" rel="noopener nofollow">Semântica</a>
<br><br>
<br>Forma das expressões, sentenças e unidades de programas
<br>Pode ser descrita por uma Gramática (Gramática Livre de Contexto e Gramática Regular)
<br><br>
<br>Significado das expressões, sentenças e unidades definidas pela sintaxe
]]></description><link>fundamentos-de-linguagens-de-programação\av1\sintaxe\definição\definição-e-história.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Sintaxe/Definição/Definição e História.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Semântica]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\sintaxe\definição\semântica.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Sintaxe/Definição/Semântica.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Sintaxe]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\sintaxe\definição\sintaxe.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Sintaxe/Definição/Sintaxe.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Adição de Partes Opcionais]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\sintaxe\ebnf\adição-de-partes-opcionais.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Sintaxe/EBNF/Adição de Partes Opcionais.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[EBNF]]></title><description><![CDATA[ 
 <br>
<br>Trata-se de uma versão estendida da BNF (Extended BNF)
<br>Três extensões comuns em diferentes implementações são:
<br><br>
<br>Representado pelo uso de colchetes 
<br>Apresenta uma parte opcional na gramática, que pode (ou não) estar presente
<br>Exemplo (if...else):

<br>&lt;if_stmt&gt;  if (&lt;expression&gt;) &lt;statement&gt; | if (&lt;expression&gt;) &lt;statement&gt; else &lt;statement&gt;
<br>&lt;if_stmt&gt;  if (&lt;expression&gt;) &lt;statement&gt; [else &lt;statement&gt;]


<br><br>
<br>Geralmente utilizado para evitar recursão gramatical
<br>Exemplo (inteiro):

<br>&lt;inteiro&gt;  &lt;inteiro&gt; &lt;digito&gt; | &lt;digito&gt;
<br>&lt;inteiro&gt;  { digito } &lt;digito&gt;


<br>Neste caso, o valor entre chaves pode aparecer 0 ou mais vezes
<br>Para forçar pelo menos uma ocorrência, poderia-se adicionar o operador "+", resultando em { digito }
<br><br>
<br>Pode-se utilizar a EBNF para "resumir" múltiplas escolhas
<br>Exemplo:

<br>&lt;term&gt;  &lt;term&gt;  &lt;factor&gt; | &lt;term&gt;  &lt;factor&gt; | &lt;term&gt;  &lt;factor&gt;
<br>&lt;term&gt;  &lt;term&gt;  &lt;factor&gt;


]]></description><link>fundamentos-de-linguagens-de-programação\av1\sintaxe\ebnf\ebnf.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Sintaxe/EBNF/EBNF.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Repetições de Termos]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\sintaxe\ebnf\repetições-de-termos.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Sintaxe/EBNF/Repetições de Termos.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Uso de Múltiplas Opções]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\sintaxe\ebnf\uso-de-múltiplas-opções.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Sintaxe/EBNF/Uso de Múltiplas Opções.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Ambiguidade]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\sintaxe\parse-trees\ambiguidade.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Sintaxe/Parse Trees/Ambiguidade.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Árvore de Análise Sintática]]></title><description><![CDATA[ 
 <br>
<br>Um dos recursos mais atrativos das gramáticas é que elas naturalmente descrevem a estrutura hierárquica (parse tree) das sentenças das linguagens que definem
<br><br><br>
<br>Uma gramática é dita ambígua quando pode gerar, para uma mesma forma sentencial, duas ou mais árvores de análise sintática
<br>Ex.: 

<br>
<br> 
<br> 


<br><br><br>
<br>A ambiguidade sintática das estruturas de linguagem é um problema porque os compiladores geralmente baseiam sua semântica nestas estruturas em sua forma sintática
<br>Se uma estrutura de linguagem tem mais de uma árvore de análise sintática, o significado da estrutura não pode ser determinado unicamente
<br><br>
<br>Uma gramática pode (ou não) apresentar uma ordem de precedência entre os operadores
<br>Isso é importante para evitar a ambiguidade e/ou erros relacionados a operações
<br>É possível modificar uma gramática para adicionar/remover precedências entre operadores:

<br>Gramática sem prioridade:

<br>
<br>


<br>Gramática com prioridade (multiplicação):

<br>
<br>
<br>
<br>




<br><br>
<br>Define-se uma prioridade para operações mais à esquerda ou à direita na árvore
<br>Geralmente ocorre quando não se há uma prioridade definida entre os operadores
]]></description><link>fundamentos-de-linguagens-de-programação\av1\sintaxe\parse-trees\árvore-de-análise-sintática.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Sintaxe/Parse Trees/Árvore de Análise Sintática.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Associatividade de Operadores]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\sintaxe\parse-trees\associatividade-de-operadores.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Sintaxe/Parse Trees/Associatividade de Operadores.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Precedência de Operadores]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\sintaxe\parse-trees\precedência-de-operadores.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Sintaxe/Parse Trees/Precedência de Operadores.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Sintaxe]]></title><description><![CDATA[ 
 <br><br><br><br>]]></description><link>fundamentos-de-linguagens-de-programação\av1\sintaxe\sintaxe.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Sintaxe/Sintaxe.md</guid><pubDate>Fri, 28 Mar 2025 01:55:41 GMT</pubDate></item><item><title><![CDATA[Fatiamento]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\matrizes\fatiamento.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Tipos de Dados/Matrizes/Fatiamento.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Inicialização]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\matrizes\inicialização.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Tipos de Dados/Matrizes/Inicialização.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Matriz Estática]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\matrizes\matriz-estática.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Tipos de Dados/Matrizes/Matriz Estática.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Matriz Heap-Dinâmica]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\matrizes\matriz-heap-dinâmica.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Tipos de Dados/Matrizes/Matriz Heap-Dinâmica.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Matriz Heap-Dinâmica Fixa]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\matrizes\matriz-heap-dinâmica-fixa.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Tipos de Dados/Matrizes/Matriz Heap-Dinâmica Fixa.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Matriz Pilha-Dinâmica]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\matrizes\matriz-pilha-dinâmica.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Tipos de Dados/Matrizes/Matriz Pilha-Dinâmica.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Matriz Pilha-Dinâmica Fixa]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\matrizes\matriz-pilha-dinâmica-fixa.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Tipos de Dados/Matrizes/Matriz Pilha-Dinâmica Fixa.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Matrizes]]></title><description><![CDATA[ 
 <br><br>
<br>Podem ser construídos a partir de tipos primitivos e/ou outros tipos compostos
<br>Processo de composição
<br><br>
<br>Conjunto de dados do mesmo tipo, em que cada elemento é identificado por sua posição relativa ao primeiro elemento
<br>A quantidade de dimensões de uma matriz pode ser variável e definida pelo programador

<br>A maioria das linguagens atualmente não impõem limites com relação à quantidade de dimensões
<br>Quanto maior o número de dimensões, maior o processamento necessário


<br>O modo de acesso dos elementos de uma matriz se dá através do uso de colchetes 

<br>Algumas linguagens utilizam parênteses, mas são menos comuns


<br><br>
<br>Algumas linguagens inicializam automaticamente os valores das matrizes
<br>Outras alocam um conjunto de valores determinados pelo programador na inicialização
<br>Outra possibilidade é o método de compreensão de listas, inspirado em nomenclaturas matemáticas:

<br>


<br>sigma = [x*x for x in range(1,10) if x % 3 == 0]
Run<br><br>
<br>Algumas linguagens permitem acessar "fatias" de vetores/matrizes
<br>Permite acessar/alterar uma faixa de valores com maior facilidade
<br><br>
<br>Uma matriz heterogênea é uma matriz que possui mais de um tipo de dados em seu interior ( [1, 2, 5, 'oi'] )
<br>Pode levar a problemas caso esteja-se realizando uma operação específica de um tipo de dados
<br><br><br>
<br>Índices fixos
<br>Alocação estática
<br>Vantagem: eficiência de alocação
<br>Desvantagem: ativa durante todo o programa
<br><br>
<br>Índices fixos
<br>Alocação de acordo com alocação dinâmica de funções
<br>Vantagem: eficiência no uso de espaço
<br>Desvantagem: tempo de alocação
<br><br>
<br>Índices dinâmicos
<br>Alocação de acordo com alocação dinâmica de funções
<br>Vantagem: flexibilidade no tamanho
<br>Desvantagem: tempo de alocação
<br><br>
<br>Índices e alocação dinâmicos
<br>Tamanho fixo depois da alocação
<br>Vantagem: flexibilidade na criação de matrizes não temporárias
<br>Desvantagem: tempo de alocação
<br><br>
<br>Índices e alocação dinâmicos
<br>Tamanho pode mudar ao decorrer da execução
<br>Vantagem: possibilidade de mudar o tamanho da matriz à medida que se insere e remove elementos
<br>Desvantagem: tempo de alocação
]]></description><link>fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\matrizes\matrizes.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Tipos de Dados/Matrizes/Matrizes.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Matrizes Heterogêneas]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\matrizes\matrizes-heterogêneas.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Tipos de Dados/Matrizes/Matrizes Heterogêneas.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Tipos Compostos]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\matrizes\tipos-compostos.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Tipos de Dados/Matrizes/Tipos Compostos.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Tipos de Matrizes]]></title><description><![CDATA[ 
 <br><a data-href="Matriz Estática" href="fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\matrizes\matriz-estática.html" class="internal-link" target="_self" rel="noopener nofollow">Matriz Estática</a><br>
<a data-href="Matriz Pilha-Dinâmica Fixa" href="fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\matrizes\matriz-pilha-dinâmica-fixa.html" class="internal-link" target="_self" rel="noopener nofollow">Matriz Pilha-Dinâmica Fixa</a><br>
<a data-href="Matriz Pilha-Dinâmica" href="fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\matrizes\matriz-pilha-dinâmica.html" class="internal-link" target="_self" rel="noopener nofollow">Matriz Pilha-Dinâmica</a><br>
<a data-href="Matriz Heap-Dinâmica Fixa" href="fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\matrizes\matriz-heap-dinâmica-fixa.html" class="internal-link" target="_self" rel="noopener nofollow">Matriz Heap-Dinâmica Fixa</a><br>
<a data-href="Matriz Heap-Dinâmica" href="fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\matrizes\matriz-heap-dinâmica.html" class="internal-link" target="_self" rel="noopener nofollow">Matriz Heap-Dinâmica</a>]]></description><link>fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\matrizes\tipos-de-matrizes.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Tipos de Dados/Matrizes/Tipos de Matrizes.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Ponteiro Solto]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\ponteiros\ponteiro-solto.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Tipos de Dados/Ponteiros/Ponteiro Solto.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Ponteiros e Variáveis de Referência]]></title><description><![CDATA[ 
 <br><br>
<br>Uma variável do tipo ponteiro possui endereços como faixas de valores
<br>Quando se deseja que um ponteiro não armazene nenhum valor, atribui-se o valor NULL a ele
<br>Podem ser usados para acessar posições na memória que são dinamicamente alocadas na memória heap
<br>Geralmente possuem duas operações: 

<br>Atribuição - Operação de associação entre um valor e um ponteiro
<br>Desreferenciamento - Permite acessar o valor armazenado no endereço apontado pelo ponteiro em questão


<br><br>
<br>Ponteiro solto - Ponteiro que contém o endereço de uma variável dinâmica no monte já liberada
<br>Variável dinâmica no monte perdida - Variável alocada que não está mais acessível para o programador, geralmente chamadas de lixo

<br>Geralmente são produzidas da seguinte forma:

<br>O ponteiro é usado para alocar uma região na memória heap
<br>O ponteiro é usado para apontar para outra variável dinâmica no monte




<br><br>
<br>Similar a um ponteiro, com a diferença que, ao invés de armazenar um endereço, a variável de referência armazena um objeto ou um valor em memória
<br>Podem (ou não) substituir os ponteiros em uma dada linguagem
]]></description><link>fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\ponteiros\ponteiros-e-variáveis-de-referência.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Tipos de Dados/Ponteiros/Ponteiros e Variáveis de Referência.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Problemas com Ponteiros]]></title><description><![CDATA[ 
 <br><a data-href="Ponteiro Solto" href="fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\ponteiros\ponteiro-solto.html" class="internal-link" target="_self" rel="noopener nofollow">Ponteiro Solto</a><a data-href="Variáveis Dinâmicas no Monte Perdidas" href="fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\ponteiros\variáveis-dinâmicas-no-monte-perdidas.html" class="internal-link" target="_self" rel="noopener nofollow">Variáveis Dinâmicas no Monte Perdidas</a>]]></description><link>fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\ponteiros\problemas-com-ponteiros.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Tipos de Dados/Ponteiros/Problemas com Ponteiros.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Variáveis de Referência]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\ponteiros\variáveis-de-referência.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Tipos de Dados/Ponteiros/Variáveis de Referência.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Variáveis Dinâmicas no Monte Perdidas]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\ponteiros\variáveis-dinâmicas-no-monte-perdidas.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Tipos de Dados/Ponteiros/Variáveis Dinâmicas no Monte Perdidas.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Booleanos]]></title><description><![CDATA[<a class="tag" href="?query=tag:true" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#true</a> <a class="tag" href="?query=tag:false" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#false</a> 
 <br><a href=".?query=tag:true" class="tag" target="_blank" rel="noopener nofollow">#true</a> <a href=".?query=tag:false" class="tag" target="_blank" rel="noopener nofollow">#false</a>]]></description><link>fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\primitivos\booleanos.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Tipos de Dados/Primitivos/Booleanos.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Caracteres]]></title><description><![CDATA[<a class="tag" href="?query=tag:char" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#char</a> <a class="tag" href="?query=tag:string" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#string</a> 
 <br><a href=".?query=tag:char" class="tag" target="_blank" rel="noopener nofollow">#char</a> <a href=".?query=tag:string" class="tag" target="_blank" rel="noopener nofollow">#string</a>]]></description><link>fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\primitivos\caracteres.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Tipos de Dados/Primitivos/Caracteres.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Tipos Numéricos]]></title><description><![CDATA[<a class="tag" href="?query=tag:int" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#int</a> <a class="tag" href="?query=tag:float" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#float</a> <a class="tag" href="?query=tag:double" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#double</a> 
 <br><a href=".?query=tag:int" class="tag" target="_blank" rel="noopener nofollow">#int</a> <a href=".?query=tag:float" class="tag" target="_blank" rel="noopener nofollow">#float</a> <a href=".?query=tag:double" class="tag" target="_blank" rel="noopener nofollow">#double</a>]]></description><link>fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\primitivos\tipos-numéricos.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Tipos de Dados/Primitivos/Tipos Numéricos.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Tipos Primitivos]]></title><description><![CDATA[ 
 <br><br>
<br>Caracteriza a faixa de valores que uma variável pode assumir
<br>Existem limitações nas faixas de valores que variam de linguagem para linguagem
<br>Tipos de dados que não são definidos em termos de outros são considerados tipos primitivos
<br>Exemplos: <a data-href="Tipos Numéricos" href="fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\primitivos\tipos-numéricos.html" class="internal-link" target="_self" rel="noopener nofollow">Tipos Numéricos</a>, <a data-href="Booleanos" href="fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\primitivos\booleanos.html" class="internal-link" target="_self" rel="noopener nofollow">Booleanos</a>, <a data-href="Caracteres" href="fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\primitivos\caracteres.html" class="internal-link" target="_self" rel="noopener nofollow">Caracteres</a>
]]></description><link>fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\primitivos\tipos-primitivos.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Tipos de Dados/Primitivos/Tipos Primitivos.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Cadeia de Caracteres]]></title><description><![CDATA[ 
 <br>
<br>Uma cadeira de caracteres (string) é um tipo onde os valores são uma sequência de caracteres
<br>As strings foram incorporadas às linguagens de programação posteriormente
<br>Existem diferentes maneiras de implementar strings:

<br>Vetor de caracteres (C)
<br>Tipo primitivo (FORTRAN, Python)
<br>Objeto (Java)


<br><br>
<br>Trata-se de uma área da memória que armazena os atributos de uma variável
<br>Se os atributos são estáticos, pode acontecer dos descritores só serem necessários em tempo de compilação
<br>Para atributos dinâmicos, parte ou todo o descritor deve ser mantido durante a execução
<br><br><br>
<br>Tamanho especificado na criação da variável (imutável)
<br>Descritor geralmente é definido em tempo de compilação e armazena informações como comprimento e endereço
<br><br>
<br>Tamanho pode variar até um limite máximo
<br>A string pode mudar de conteúdo (desde que não ultrapasse o limite máximo)
<br>Descritor é definido em tempo de execução e armazena informações como comprimento atual, comprimento máximo e endereço
<br><br>
<br>Descritor definido em tempo de execução
<br>Permite alterar tanto o conteúdo quanto o tamanho máximo da string
<br>Alocação e liberação de memória são os principais problemas de implementação
]]></description><link>fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\strings\cadeia-de-caracteres.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Tipos de Dados/Strings/Cadeia de Caracteres.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Descritor]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\strings\descritor.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Tipos de Dados/Strings/Descritor.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Tamanho de Strings]]></title><description><![CDATA[ 
 <br><a data-href="Tamanho Estático" href="fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\strings\tamanho-estático.html" class="internal-link" target="_self" rel="noopener nofollow">Tamanho Estático</a><a data-href="Tamanho Dinâmico Limitado" href="fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\strings\tamanho-dinâmico-limitado.html" class="internal-link" target="_self" rel="noopener nofollow">Tamanho Dinâmico Limitado</a><a data-href="Tamanho Dinâmico Ilimitado" href="fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\strings\tamanho-dinâmico-ilimitado.html" class="internal-link" target="_self" rel="noopener nofollow">Tamanho Dinâmico Ilimitado</a>]]></description><link>fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\strings\tamanho-de-strings.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Tipos de Dados/Strings/Tamanho de Strings.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Tamanho Dinâmico Ilimitado]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\strings\tamanho-dinâmico-ilimitado.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Tipos de Dados/Strings/Tamanho Dinâmico Ilimitado.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Tamanho Dinâmico Limitado]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\strings\tamanho-dinâmico-limitado.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Tipos de Dados/Strings/Tamanho Dinâmico Limitado.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Tamanho Estático]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\strings\tamanho-estático.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Tipos de Dados/Strings/Tamanho Estático.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Registros]]></title><description><![CDATA[ 
 <br>
<br>Um registro é um agregado de elementos de dados no qual os elementos individuais são identificados por nomes
<br>Os elementos de um registro ocupam posições de memória adjacentes
<br>A principal diferença de um registro para uma matriz é que os elementos/campos do registro não são acessados por índices
<br>Ex.: structs em C/C++/C#
]]></description><link>fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\registros.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Tipos de Dados/Registros.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Tipos de Dados]]></title><description><![CDATA[ 
 <br><br><br><br><br><br>]]></description><link>fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\tipos-de-dados.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Tipos de Dados/Tipos de Dados.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Verificação de Tipos]]></title><description><![CDATA[ 
 <br>
<br>Um sistema de tipos define como tipos e variáveis são associados e como as operações sobre os seus valores são realizadas
<br>Impõe restrições sobre operações
<br>Essa verificação pode ocorrer em tempo de compilação (verificação estática) ou execução (verificação dinâmica)
<br>O tipo de uma variável pode ser determinado estaticamente ou dinamicamente
<br>A verificação ocorre da mesma forma que a tipagem (estático - estático, dinâmico - dinâmico)
<br>Uma linguagem é dita fortemente tipada quando sempre é capaz de detectar erros de tipo
]]></description><link>fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\verificação-de-tipos.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/Tipos de Dados/Verificação de Tipos.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[AV1]]></title><description><![CDATA[ 
 <br>
<br><a data-href="Conceitos Preliminares" href="fundamentos-de-linguagens-de-programação\av1\conceitos-preliminares\conceitos-preliminares.html" class="internal-link" target="_self" rel="noopener nofollow">Conceitos Preliminares</a>
<br><a data-href="Nomes, variáveis, vinculações e escopos" href="fundamentos-de-linguagens-de-programação\av1\nvve\nomes,-variáveis,-vinculações-e-escopos.html" class="internal-link" target="_self" rel="noopener nofollow">Nomes, variáveis, vinculações e escopos</a>
<br><a data-tooltip-position="top" aria-label="AV1/Sintaxe/Sintaxe" data-href="AV1/Sintaxe/Sintaxe" href="fundamentos-de-linguagens-de-programação\av1\sintaxe\sintaxe.html" class="internal-link" target="_self" rel="noopener nofollow">Sintaxe</a>
<br><a data-href="Tipos de Dados" href="fundamentos-de-linguagens-de-programação\av1\tipos-de-dados\tipos-de-dados.html" class="internal-link" target="_self" rel="noopener nofollow">Tipos de Dados</a>
<br><a data-href="Python - Memória e Garbage Collector" href="fundamentos-de-linguagens-de-programação\av1\python\python-memória-e-garbage-collector.html" class="internal-link" target="_self" rel="noopener nofollow">Python - Memória e Garbage Collector</a>
]]></description><link>fundamentos-de-linguagens-de-programação\av1\av1.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV1/AV1.md</guid><pubDate>Fri, 28 Mar 2025 01:55:40 GMT</pubDate></item><item><title><![CDATA[Método de Implementação]]></title><description><![CDATA[ 
 <br>
<br>A linguagem Java utiliza um sistema híbrido de implementação
<br>Ela é compilada até a geração do código intermediário em bytecodes
<br>Após isso, o interpretador da JVM executa os bytecodes e produz os resultados desejados
]]></description><link>fundamentos-de-linguagens-de-programação\av2\java\implementação\método-de-implementação.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Java/Implementação/Método de Implementação.md</guid><pubDate>Thu, 15 May 2025 00:06:33 GMT</pubDate></item><item><title><![CDATA[Memória]]></title><description><![CDATA[ 
 <br>
<br>À medida em que as funções são chamadas, as variáveis que são tipos primitivos são empilhadas na memória Stack
<br>Quando objetos são criados, eles são alocados na memória Heap

<br>Ao mesmo tempo, as variáveis de referência desses objetos são empilhadas na memória Stack


<br>O comportamento dos tipos primitivos na memória é similar à linguagem C, enquanto o comportamento dos objetos é semelhante ao Python
<br><br>
<br>Por Java ter como base o paradigma de orientação a objetos, o conceito de variáveis estáticas é diferente de linguagens como C
<br>Em Java, uma variável estática é uma variável que está relacionada com uma classe
<br>Essa variável é alocada na memória assim que a classe é carregada pela JVM
<br>Quando acrescenta-se a palavra reservada final em uma variável estática, obtém-se um comportamento semelhante ao de uma constante
<br>Não é necessário criar um objeto para acessar uma variável estática
]]></description><link>fundamentos-de-linguagens-de-programação\av2\java\memória\memória.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Java/Memória/Memória.md</guid><pubDate>Mon, 05 May 2025 02:33:06 GMT</pubDate></item><item><title><![CDATA[Orientação a Objetos]]></title><description><![CDATA[ 
 <br>
<br>Java é uma linguagem que foi projetada para o paradigma de orientação a objetos
<br>Cada objeto pode possuir um conjunto de atributos e um conjunto de métodos
<br>Pode-se dizer que os atributos dos objetos são variáveis de instância
<br>As variáveis de instância podem ser públicas, privadas ou protegidas

<br>Públicas - Podem ser acessadas em qualquer contexto
<br>Protegidas - Podem ser acessadas apenas por códigos no mesmo pacote da classe da variável
<br>Privadas - Podem ser acessadas apenas por membros que estão na mesma classe que a variável


<br>Normalmente, é uma boa prática deixar as variáveis de instância com acesso privado

<br>Para alterar os valores dessas variáveis, utilizam-se os métodos get e set
<br>Caracteriza a prática de encapsulamento de código, que protege o código contra acesso indevido às variáveis


]]></description><link>fundamentos-de-linguagens-de-programação\av2\java\orientação-a-objetos\orientação-a-objetos.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Java/Orientação a Objetos/Orientação a Objetos.md</guid><pubDate>Mon, 05 May 2025 02:33:00 GMT</pubDate></item><item><title><![CDATA[Sintaxe]]></title><description><![CDATA[ 
 <br>
<br>A sintaxe do Java é bastante similar à sintaxe da linguagem C
<br>Para abrir e fechar blocos de código, utilizam-se chaves ("{" e "}")
<br><br>
<br>Para declarar uma variável, Java usa o padrão &lt;tipo&gt; &lt;nome_da_variável&gt;
<br>Além disso, o operador = é usado para atribuição de valores para as variáveis
<br>Exemplo:
<br>public class Main {
	public static void main(String[] args) {
		int a;
		double b;
		a = 10;
		b = 4.5;
		System.out.println(a);
		System.out.println(b);
	}
}
Run<br><br>public class Main {
	public static void main(String[] args) {
		int a, b;
		a = 10;
		b = 5;
		if (a &gt; b) {
			System.out.println("a é maior");
		} else {
			System.out.println("b é maior (ou igual)");
		}
	}
}
Run<br><br>// while
public class Main {
	public static void main(String[] args) {
		x = 15;
		while (x &gt;= 1) {
			System.out.println(x);
			x--;
		}
	}
}
Run<br>// for
public class Main {
	public static void main(String[] args) {
		for (int i = 0; i &lt; 15; i++) {
			System.out.println(i);
		}
	}
}
Run]]></description><link>fundamentos-de-linguagens-de-programação\av2\java\sintaxe\sintaxe.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Java/Sintaxe/Sintaxe.md</guid><pubDate>Mon, 05 May 2025 02:32:57 GMT</pubDate></item><item><title><![CDATA[Tipos]]></title><description><![CDATA[ 
 <br>
<br>A vinculação de tipos acontece de forma estática
<br>Por conta disso, é possível realizar a verificação de tipos de forma estática
<br>A linguagem verifica erros relacionados à tipagem, então pode-se dizer que ela é fortemente tipada
<br><br><br><br>
<br>Objetos são considerados tipos não primitivos na linguagem Java

<br>Vetores, matrizes e strings se enquadram nessa categoria


]]></description><link>fundamentos-de-linguagens-de-programação\av2\java\tipos\tipos.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Java/Tipos/Tipos.md</guid><pubDate>Mon, 05 May 2025 02:33:03 GMT</pubDate></item><item><title><![CDATA[Linguagem Java]]></title><description><![CDATA[ 
 <br>Método de Implementação<br><br>
<br>A linguagem Java utiliza um sistema híbrido de implementação
<br>Ela é compilada até a geração do código intermediário em bytecodes
<br>Após isso, o interpretador da JVM executa os bytecodes e produz os resultados desejados
<br><br><br><br>]]></description><link>fundamentos-de-linguagens-de-programação\av2\java\linguagem-java.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Java/Linguagem Java.md</guid><pubDate>Thu, 03 Apr 2025 18:48:45 GMT</pubDate></item><item><title><![CDATA[Noções de LISP]]></title><description><![CDATA[ 
 <br>
<br>Uma das linguagens funcionais mais utilizadas, bem como a mais antiga existente, é a linguagem LISP
<br>Apesar de ter sido a primeira linguagem funcional, ela permite alguns recursos de linguagens imperativas como variáveis, sentenças de atribuição e iteração

<br>Apesar disso, a linguagem LISP e seus descendentes representam bem os conceitos fundamentais da programação funcional


<br>Existem apenas dois tipos de dados no LISP original: átomos e listas

<br>Estes tipos não funcionam da mesma maneira que os tipos em linguagens imperativas


<br>Os átomos são símbolos, seja na forma de identificadores ou literais numéricos
<br>As listas são especificadas ao delimitar elementos entre parênteses

<br>É possível criar listas aninhadas inserindo listas dentro de outras


<br>As chamadas de funções também possuem as listas como base, possuindo o formato (nome_da_função argumento1 argumento2 argumento_n)
]]></description><link>fundamentos-de-linguagens-de-programação\av2\lisp\noções-de-lisp.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/LISP/Noções de LISP.md</guid><pubDate>Thu, 03 Apr 2025 04:13:13 GMT</pubDate></item><item><title><![CDATA[Funções Matemáticas]]></title><description><![CDATA[ 
 <br>
<br>Uma função matemática é um mapeamento de elementos de um conjunto, chamado de conjunto domínio, para outro, denominado de contradomínio
<br>As funções aplicadas a um elemento em particular do conjunto domínio, fornecido como parâmetro para a função
<br>Uma função mapeia um elemento do domínio para um único elemento do contradomínio
<br><br>
<br>As funções geralmente são descritas por um nome, seguido de um conjunto de parâmetros entre parênteses

<br>Exemplo: 


<br>Após isso, se segue uma expressão de mapeamento, isto é, uma atribuição
<br>Nessa definição, tanto o domínio quanto o contradomínio são números reais
<br>O parâmetro x pode representar qualquer membro do conjunto do domínio, mas é fixado para representar um elemento específico durante a avaliação da expressão da função
<br><br>
<br>São uma forma de criar funções sem nomes
<br>Apenas define o mapeamento e os parâmetros
<br>São bastante úteis em linguagens funcionais
<br><br>
<br>Também chamada de função de ordem superior, trata-se de uma função que recebe funções como parâmetros ou que tem como resultado/retorno uma função
<br>Um tipo comum de forma funcional são as funções compostas
<br><br>
<br>Forma funcional que recebe uma função e uma lista como parâmetros, aplicando a função para cada um dos valores da lista
]]></description><link>fundamentos-de-linguagens-de-programação\av2\programação-funcional\funções-matemáticas\funções-matemáticas.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Programação Funcional/Funções Matemáticas/Funções Matemáticas.md</guid><pubDate>Thu, 03 Apr 2025 18:49:15 GMT</pubDate></item><item><title><![CDATA[Programação Funcional]]></title><description><![CDATA[ 
 <br>
<br>Possui como objetivo mimetizar ao máximo as funções matemáticas
<br>Uma função puramente funcional não usa variáveis ou sentenças de atribuição, liberando o programador de se preocupar com o estado da memória
<br>A execução de uma função sempre produz o mesmo resultado quando fornecidos os mesmos parâmetros

<br>Recurso conhecido como transparência referencial


<br>Uma linguagem funcional fornece:

<br>Funções primitivas
<br>Formas funcionais
<br>Operação de Aplicação de Função
<br>Estruturas de Representação de Dados


<br>Apesar de serem, em sua maioria, interpretadas, linguagens funcionais também podem ser compiladas
]]></description><link>fundamentos-de-linguagens-de-programação\av2\programação-funcional\programação-funcional\programação-funcional.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Programação Funcional/Programação Funcional/Programação Funcional.md</guid><pubDate>Thu, 03 Apr 2025 18:49:20 GMT</pubDate></item><item><title><![CDATA[Paradigma de Programação Funcional]]></title><description><![CDATA[ 
 <br>
<br>As linguagens de programação imperativas são bastante similares, pois possuem uma base em comum de projeto: a arquitetura de von Neummann
<br>Apesar do estilo imperativo ser considerado como aceitável pela maioria dos programadores, alguns afirmam que sua forte dependência com a arquitetura é uma restrição desnecessária
<br>Atualmente, poucos programas são/têm sido escritos em linguagens não-imperativas
<br><br>]]></description><link>fundamentos-de-linguagens-de-programação\av2\programação-funcional\paradigma-de-programação-funcional.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Programação Funcional/Paradigma de Programação Funcional.md</guid><pubDate>Thu, 03 Apr 2025 18:49:12 GMT</pubDate></item><item><title><![CDATA[Prolog]]></title><description><![CDATA[ 
 <br>
<br>Linguagem que utiliza o paradigma lógico de programação
<br>Normalmente aplicada em Inteligência Artificial e Linguística Computacional
<br>Trata-se de uma linguagem declarativa, ou seja, ao invés de programar passo a passo um conjunto de instruções, é fornecido uma descrição do problema a ser resolvido
<br>Existem três conceitos fundamentais: fatos, regras e objetivos
<br>Uma coleção de fatos e regras é denominada de base de conhecimento
<br>Após a construção da base de conhecimento, pode-se alcançar os objetivos desejados através de perguntas (queries)
<br><br>
<br>Os fatos, regras e objetivos são construídos através de termos
<br>Antes de entender os termos, é necessário entender os símbolos disponíveis em Prolog:

<br>Letras Maiúsculas e Minúsculas
<br>Dígitos
<br>Caracteres Especiais


<br>Em Prolog, existem quatro tipos de termos: átomos, números, variáveis e termos complexos
<br><br>
<br>Um átomo é:

<br>Um conjunto de caracteres que começa com letra minúscula e pode conter letras maiúsculas, dígitos e o caractere underscore ( _ )
<br>Uma sequência de caracteres entre aspas simples
<br>Uma sequência de caracteres especiais


<br>Alguns desses átomos têm significados especiais na linguagem
<br><br>
<br>Divididos em dois grupos:

<br>Ponto Flutuante - Apesar de não serem tão comuns, a linguagem Prolog tem suporte a números com ponto flutuante
<br>Inteiros - Mais comuns, são úteis em diversas aplicações de Prolog


<br><br>
<br>Uma variável se trata de uma cadeia de caracteres que inicia com letra maiúscula ou underscore
<br>Pode conter letras minúsculas, dígitos e o símbolo underscore
<br>A variável _, constituída apenas por um underscore, é especial, sendo designada por variável anônima
<br><br>
<br>Os termos complexos são constituídos por um functor seguido de uma sequência de argumentos
<br>Um functor precisa ser um átomo, ou seja, variáveis não podem ser usadas como functores

<br>Por outro lado, os argumentos podem ser quaisquer termos


<br>A definição de functor permite escrever termos mais complexos que os vistos anteriormente (por exemplo, construir termos complexos a partir de outros termos complexos)
<br>O número de argumentos que um termo complexo possui é a sua aridade

<br>A aridade é bastante importante em Prolog, já que é permitido que se definam dois functores com o mesmo nome e aridades diferentes
<br>Na documentação de Prolog, é comum representar os predicados com o sufixo / seguido de um número que indica a sua aridade


<br><br>
<br>Ao responder uma consulta, o interpretador Prolog precisa instanciar as variáveis, isto é, atribuir valor a elas
<br>Informalmente, diz-se que os dois termos podem ser unificados se eles são iguais ou possuem variáveis que podem ser instanciadas de forma a tornar os termos idênticos
<br>Formalmente, pode-se dizer que dois termos podem ser unificados se, e somente se, uma das condições abaixo for verdadeira:

<br>Os dois termos são constantes (números ou átomos) e iguais
<br>Um dos termos é uma variável
<br>Ambos os termos são complexos com o mesmo functor, a mesma aridade e os argumentos correspondentes podem ser unificados


<br>O predicado = pode ser usado para verificar se dois termos são unificáveis
<br><br>
<br>É possível definir um predicado recursivamente
<br>Informalmente, um predicado é definido por recursão se houver referências a si próprio em uma ou mais regras de sua definição
<br><br>
<br>Podem ser vistas como conjuntos de itens
<br>São especificadas ao escrever os seus elementos entre colchetes, sendo separados por vírgula
<br>Qualquer objeto Prolog pode fazer parte de uma lista
<br>O mesmo elemento pode ocorrer mais de uma vez
<br>Uma lista vazia é aquela que não possui nenhum elemento
<br><br>
<br>Uma lista não vazia pode ser vista como sendo constituída de duas partes:

<br>Cabeça - Primeiro elemento da lista
<br>Cauda - Restante da lista


<br>Podem ser definidos seguindo a estrutura:
<br>[Cabeça|Cauda] = [X, Y, Z]
Cabeça = X
Cauda = [Y, Z]
Run<br><br>
<br>
]]></description><link>fundamentos-de-linguagens-de-programação\av2\prolog\prolog.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Prolog/Prolog.md</guid><pubDate>Sun, 04 May 2025 17:57:24 GMT</pubDate></item><item><title><![CDATA[Scheme]]></title><description><![CDATA[ 
 <br>
<br>Linguagem baseada em LISP criada por volta da década de 1970
<br>Por ser uma linguagem pequena, possui uma semântica e sintaxe simples
<br>Linguagem adequada para aplicações educacionais sobre programação funcional
<br><br>
<br>A linguagem Scheme possui um conjunto de funções primitivas para operações aritméticas básicas:

<br>(+ x y) - Adição
<br>(- x y) - Subtração
<br>(* x y) - Multiplicação
<br>(/ x y) - Divisão


<br><br>
<br>A linguagem permite a criação de expressões lambda
<br>A sintaxe é dada por (lambda (parameters) body values)

<br>Parameters - Lista de variáveis/argumentos
<br>Body - Corpo da função, define o código que será realizado
<br>Values - Valores que serão passados para execução da função


<br><br>
<br>Em Scheme, é possível vincular um nome a um valor ou expressão lambda
<br>A expressão usada para definir valores é (define nome expressão)
<br>A forma geral para vincular um nome a uma expressão lambda é (define (nome_função parâmetros) (expressão))
<br><br>
<br>Uma função de predicado é qualquer uma que retorna um valor booleano:

<br>= - Igual
<br>&lt; - Menor
<br>&gt; - Maior
<br>&gt;= - Maior ou igual
<br>&lt;= - Menor ou igual
<br>even? - Par
<br>odd? - Ímpar


<br><br>
<br>Em síntese, são funções condicionais
<br>As principais são as funções if e cond
<br><br>
<br>Possui a estrutura (if predicado expressão_verdadeiro expressão_falso)
<br>(define (fatorial n)
	(if (&lt;= n 1)
	    1
	    (* n (fatorial (- n 1)))
	)
)
<br><br>
<br>Permite a construção de expressões com 2 ou mais predicados
<br>Possui a estrutura (cond ((condição1) resultado1) ((condição2) resultado2) ((condição3) resultado3))
<br>Também é possível usar a estrutura else para executar um código quando nenhuma das condições for satisfeita:
<br>(cond
	((= n 0) "Nulo")
	((&gt; n 0) "Positivo")
	(else "Negativo")
)
<br><br><br>
<br>A linguagem Scheme analisa sempre o primeiro elemento de uma lista para saber que operação deve realizar
<br>A função quote é usada para definir uma lista que possui apenas elementos, ou seja, não possui uma função
<br>Sintaxe: (quote (A B C D))
<br><br>
<br>A função car retorna o primeiro elemento de uma lista, semelhante ao array[0] que é mais comum atualmente
<br>A função cdr, por outro lado, retorna todos os elementos exceto o primeiro
<br><br>
<br>Utilizado para comparar símbolos

<br>Um símbolo é definido usando um apóstrofe antes da letra/símbolo desejado
<br>Caso contrário, o mesmo é tratado como uma variável


<br>Sintaxe: (eq? 'x 'y)
<br><br>
<br>Usada para comparar tanto números quanto símbolos
<br>Sintaxe similar à função eq?
<br><br>
<br>A função list? retorna verdadeiro caso o argumento passado a ela seja uma lista
<br>A função null? retorna verdadeiro caso a lista passada esteja vazia
]]></description><link>fundamentos-de-linguagens-de-programação\av2\scheme\scheme.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Scheme/Scheme.md</guid><pubDate>Sat, 03 May 2025 03:14:26 GMT</pubDate></item><item><title><![CDATA[Contextualização]]></title><description><![CDATA[ 
 <br><br>
<br>Subprogramas são fundamentais para a reutilização de código
<br>O primeiro computador programável de Charles Babbage tinha a capacidade de reutilizar uma coleção de cartões de instruções em diferentes lugares do programa
<br>Em uma linguagem moderna, essa coleção de sentenças são escritas na forma de subprogramas
<br>O reúso de código possibilitado por subprogramas podem economizar memória e tempo de codificação
<br><br>
<br>Subprogramas são capazes de fornecer abstração para diversos processos computacionais
<br>Subprogramas também podem ser vistos como uma abstração
<br>Os detalhes de computação dos subprogramas são substituídos em um programa por uma sentença que chama o subprograma
<br>Dessa forma, quem usa o subprograma não precisa conhecer os detalhes de programação dele
<br>Melhora a facilidade de leitura de um programa ao dar ênfase em sua estrutura lógica ao mesmo tempo em que esconde detalhes de baixo nível
]]></description><link>fundamentos-de-linguagens-de-programação\av2\subprogramas\contextualização\contextualização.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Subprogramas/Contextualização/Contextualização.md</guid><pubDate>Thu, 03 Apr 2025 18:48:17 GMT</pubDate></item><item><title><![CDATA[Definições Básicas]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av2\subprogramas\fundamentos\definições-básicas.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Subprogramas/Fundamentos/Definições Básicas.md</guid><pubDate>Fri, 28 Mar 2025 01:52:24 GMT</pubDate></item><item><title><![CDATA[Fundamentos de Subprogramas]]></title><description><![CDATA[ 
 <br><br>
<br>A unidade de programa chamadora é suspensa durante a execução do subprograma chamado, implicando a existência de apenas um subprograma em execução em qualquer momento no tempo
<br>O controle sempre retorna para o chamador quando a execução do subprograma termina
<br>Uma definição de subprograma descreve a interface e as ações de abstração do mesmo
<br>Uma chamada a subprograma é a requisição explícita para que ele seja executado
<br>Um subprograma é dito ativo se, após ter sido chamado, o mesmo começou sua execução, mas ainda não a terminou
<br>Um cabeçalho de subprograma geralmente especifica se o subprograma é uma função ou um procedimento

<br>Em algumas linguagens, o cabeçalho também pode conter o tipo de um subprograma
<br>O nome do subprograma deve aparecer no cabeçalho
<br>Uma lista de parâmetros também pode ser especificada no cabeçalho


<br><br>
<br>Subprogramas normalmente descrevem computações
<br>Existem duas maneiras pelas quais um subprograma pode ganhar acesso aos dados que serão processados:

<br>Acesso direto a variáveis não locais (declaradas em outros locais, mas visíveis no subprograma)
<br>Passagem de parâmetros


<br>Parâmetros podem ser definidos como dois subgrupos:

<br>Parâmetros formais - Parâmetros definidos no cabeçalho do subprograma
<br>Parâmetros reais - Também chamados de argumentos, são os valores passados na subchamada do programa


<br>Em praticamente todas as linguagens de programação, a correspondência entre parâmetros reais e formais é feita pela posição, isto é, o primeiro parâmetro real é vinculado ao primeiro formal e assim por diante

<br>Parâmetros com essas características são chamados de parâmetros posicionais


<br>Quando a lista de parâmetros é muito grande, pode ocorrer confusão com a ordem dos parâmetros. Para resolver este problema, algumas linguagens fornecem parâmetros com palavras-chave, permitindo ao programador não seguir necessariamente a ordem definida dos parâmetros
<br>Algumas linguagens permitem com que parâmetros formais tenham valores padrão

<br>O valor padrão é usado caso nenhum parâmetro real seja passado para o parâmetro formal no cabeçalho do subprograma


<br><br>
<br>Existem duas categorias de subprogramas:
<br><br>
<br>Coleções de sentenças que definem computações parametrizadas
<br>Procedimentos podem produzir resultados na unidade de programa que os chamam por dois métodos:

<br>Se existirem variáveis que não são parâmetros formais, mas mesmo assim estão visíveis tanto no procedimento quanto na unidade de programa chamadora, o procedimento pode modificá-las
<br>Se o subprograma tem parâmetros formais que permitem a transferência de dados para o chamador, esses parâmetros podem ser modificados


<br><br>
<br>Se parecem estruturalmente com os procedimentos, mas são semanticamente modeladas como funções matemáticas
<br>Se uma função é um modelo fiel, não produz efeitos colaterais (não modifica seus parâmetros ou variáveis definidas fora dela)

<br>Esta função pura retorna um valor, que é o único efeito desejado
<br>Na prática, muitas funções em programas têm efeitos colaterais


<br>Funções são chamadas por meio da aparição de seus nomes em expressões, com os parâmetros reais requeridos
<br>O valor produzido pela execução de uma função é retornado para o código chamador, substituindo a chamada propriamente dita
<br>Funções definem novos operadores definidos pelo usuário
]]></description><link>fundamentos-de-linguagens-de-programação\av2\subprogramas\fundamentos\fundamentos-de-subprogramas.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Subprogramas/Fundamentos/Fundamentos de Subprogramas.md</guid><pubDate>Fri, 28 Mar 2025 01:52:24 GMT</pubDate></item><item><title><![CDATA[Parâmetros]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av2\subprogramas\fundamentos\parâmetros.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Subprogramas/Fundamentos/Parâmetros.md</guid><pubDate>Fri, 28 Mar 2025 01:52:24 GMT</pubDate></item><item><title><![CDATA[Procedimentos e Funções]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av2\subprogramas\fundamentos\procedimentos-e-funções.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Subprogramas/Fundamentos/Procedimentos e Funções.md</guid><pubDate>Fri, 28 Mar 2025 01:52:24 GMT</pubDate></item><item><title><![CDATA[Passagem de Parâmetros]]></title><description><![CDATA[ 
 <br>
<br>Métodos de passagem de parâmetros são as maneiras como os parâmetros são transmitidos para os subprogramas ou a partir deles
<br><br>
<br>Parâmetros formais são caracterizados por um dos três modelos semânticos distintos:

<br>Receber dados a partir do parâmetro real correspondente
<br>Transmitir dados para o parâmetro real
<br>Fazer ambos


<br>Esses três modelos semânticos são chamados de modo de entrada, modo de saída e modo de entrada e saída respectivamente
<br>Os modelos semânticos de passagem de parâmetros podem ser implementados através de:

<br>Passagem por valor
<br>Passagem por resultado
<br>Passagem por valor-resultado
<br>Passagem por referência
<br>Passagem por nome


<br><br>
<br>Quando um parâmetro é passado por valor, o valor do parâmetro real é usado para inicializar o parâmetro formal correspondente, que age como uma variável local no subprograma
<br>Implementa a semântica de modo de entrada
<br>Normalmente é implementada por cópia, porque os acessos são mais eficientes com essa abordagem
<br><br>
<br>Modelo de implementação para parâmetros do modo de saída
<br>Quando um parâmetro é passado por resultado, nenhum valor é transmitido para o subprograma
<br>O parâmetro formal correspondente age como uma variável local, mas antes do controle ser transmitido de volta para o chamador, seu valor é transmitido para o parâmetro real deste
<br><br>
<br>Modelo de implementação para parâmetros no modo de entrada e saída no qual os valores reais são copiados
<br>O valor do parâmetro real é usado para inicializar o parâmetro formal correspondente, que age como uma variável local
<br>Os parâmetros formais com passagem por valor-resultado devem ter o armazenamento local associado com o subprograma chamado
<br>Ao término do subprograma, o valor do parâmetro formal é transmitido de volta para o parâmetro real
<br>É uma combinação da passagem de valor com a passagem por resultado

<br>Compartilha as desvantagens de requerer armazenamento múltiplo para parâmetros e tempo para copiar valores
<br>Compartilha com a passagem por resultado os problemas associados com a ordem de atribuição dos parâmetros reais


<br><br>
<br>Modelo de implementação para parâmetros no modo de entrada e saída
<br>Em vez de copiar os valores de dados de um lado para o outro, o método transmite um caminho de acesso, normalmente um endereço para o subprograma chamado

<br>Isso fornece o caminho de acesso para a célula que está armazenando o parâmetro real
<br>O subprograma chamado pode acessar o parâmetro real na unidade de programa chamadora, ou seja, o parâmetro real é compartilhado com o subprograma chamado


<br>A vantagem da passagem por referência é que o processo de passagem é eficiente por si só, em termos de tempo e espaço
<br>Possui as seguintes desvantagens:

<br>Acesso aos parâmetros formais é mais lento que nos parâmetros com passagem por valor
<br>Se apenas a comunicação de uma via para o subprograma chamado é necessária, mudanças errôneas podem ser feitas ao parâmetro real
<br>Criação de apelidos é prejudicial para legibilidade e confiabilidade


]]></description><link>fundamentos-de-linguagens-de-programação\av2\subprogramas\passagem-de-parâmetros\passagem-de-parâmetros.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Subprogramas/Passagem de Parâmetros/Passagem de Parâmetros.md</guid><pubDate>Thu, 03 Apr 2025 18:48:25 GMT</pubDate></item><item><title><![CDATA[Questões de Projeto para Subprogramas]]></title><description><![CDATA[ 
 <br>
<br>Um subprograma carregado é aquele que tem o mesmo nome de outro subprograma no mesmo ambiente de referenciamento
<br>Um subprograma genérico é um cuja computação pode ser feita em dados de diferentes tipos em diferentes camadas
]]></description><link>fundamentos-de-linguagens-de-programação\av2\subprogramas\questões-de-projeto\questões-de-projeto-para-subprogramas.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Subprogramas/Questões de Projeto/Questões de Projeto para Subprogramas.md</guid><pubDate>Fri, 28 Mar 2025 01:52:24 GMT</pubDate></item><item><title><![CDATA[Variáveis Definidas em Subprogramas]]></title><description><![CDATA[ 
 <br>
<br>Variáveis definidas dentro de subprogramas são denominadas por variáveis locais, já que normalmente seu escopo é o corpo do subprograma
<br>As variáveis locais podem ser:
<br><br>
<br>Podem ser usadas para recursão
<br>Memória será liberada em um determinado momento e poderá ser usada posteriormente
<br>Gasta um maior tempo para inicializar, ser alocada e depois desalocada
<br>Subprogramas não são sensíveis ao histórico
<br><br>
<br>São mais eficientes, já que não precisam ser alocadas e desalocadas em tempo de execução
<br>Permitem aos subprogramas serem sensíveis ao histórico
<br>Não suporta recursão
<br>A região fica alocada durante toda a execução do programa e não poderá ser liberada para uso posterior enquanto o programa estiver ativo
]]></description><link>fundamentos-de-linguagens-de-programação\av2\subprogramas\variáveis\variáveis-definidas-em-subprogramas.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Subprogramas/Variáveis/Variáveis Definidas em Subprogramas.md</guid><pubDate>Fri, 28 Mar 2025 01:52:24 GMT</pubDate></item><item><title><![CDATA[Subprogramas e Abstração de Processos]]></title><description><![CDATA[ 
 <br><br><br>Questões de Projeto para Subprogramas<br><br><br>
<br>Um subprograma carregado é aquele que tem o mesmo nome de outro subprograma no mesmo ambiente de referenciamento
<br>Um subprograma genérico é um cuja computação pode ser feita em dados de diferentes tipos em diferentes camadas
<br>Variáveis Definidas em Subprogramas<br><br><br>
<br>Variáveis definidas dentro de subprogramas são denominadas por variáveis locais, já que normalmente seu escopo é o corpo do subprograma
<br>As variáveis locais podem ser:
<br><br>
<br>Podem ser usadas para recursão
<br>Memória será liberada em um determinado momento e poderá ser usada posteriormente
<br>Gasta um maior tempo para inicializar, ser alocada e depois desalocada
<br>Subprogramas não são sensíveis ao histórico
<br><br>
<br>São mais eficientes, já que não precisam ser alocadas e desalocadas em tempo de execução
<br>Permitem aos subprogramas serem sensíveis ao histórico
<br>Não suporta recursão
<br>A região fica alocada durante toda a execução do programa e não poderá ser liberada para uso posterior enquanto o programa estiver ativo
<br>]]></description><link>fundamentos-de-linguagens-de-programação\av2\subprogramas\subprogramas-e-abstração-de-processos.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Subprogramas/Subprogramas e Abstração de Processos.md</guid><pubDate>Fri, 28 Mar 2025 01:52:24 GMT</pubDate></item><item><title><![CDATA[Abstração]]></title><description><![CDATA[ 
 <br>
<br>Pode ser visto como o processo que separa as ideias dos objetos
<br>Usa a estratégia da simplificação de detalhes, deixando-os ambíguos, vagos ou indefinidos
<br>No contexto de linguagens de programação, trata-se de uma ferramenta para simplificar o processo de programação
<br>Possui dois tipos fundamentais:
<br><br>
<br>Modo de fornecer uma especificação de processo sem necessariamente fornecer os detalhes de sua execução
<br>De certa forma, todo procedimento/função é considerado uma abstração de processo
<br>Melhora a legibilidade do código e permite modularidade
<br>Exemplo:
<br>def soma(a : int, b : int): # função original
	return a + b

resultado = soma(5, 8) # abstração de processo
print(resultado)
Run<br><br>
<br>Agrupa alguns elementos, como conjuntos de valores e conjuntos de operações sobre esses valores
<br>O usuário de um tipo abstrato de dados tem acesso às especificações, mas não à implementação
]]></description><link>fundamentos-de-linguagens-de-programação\av2\tipos-abstratos\abstração\abstração.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Tipos Abstratos/Abstração/Abstração.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Abstração de Dados]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av2\tipos-abstratos\abstração\abstração-de-dados.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Tipos Abstratos/Abstração/Abstração de Dados.md</guid><pubDate>Thu, 03 Apr 2025 18:48:57 GMT</pubDate></item><item><title><![CDATA[Abstração de Processos]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av2\tipos-abstratos\abstração\abstração-de-processos.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Tipos Abstratos/Abstração/Abstração de Processos.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Atributo]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av2\tipos-abstratos\classes\atributo.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Tipos Abstratos/Classes/Atributo.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[Classe]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av2\tipos-abstratos\classes\classe.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Tipos Abstratos/Classes/Classe.md</guid><pubDate>Fri, 28 Mar 2025 01:55:43 GMT</pubDate></item><item><title><![CDATA[Classes e Objetos]]></title><description><![CDATA[ 
 <br>
<br>Uma linguagem orientada a objetos deve fornecer suporte para três recursos chaves: <a data-tooltip-position="top" aria-label="FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Tipos Abstratos/Abstração/Abstração de Dados" data-href="FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Tipos Abstratos/Abstração/Abstração de Dados" href="fundamentos-de-linguagens-de-programação\av2\tipos-abstratos\abstração\abstração-de-dados.html" class="internal-link" target="_self" rel="noopener nofollow">abstração de dados</a>, <a data-tooltip-position="top" aria-label="Herança" data-href="Herança" href="fundamentos-de-linguagens-de-programação\av2\tipos-abstratos\herança\herança.html" class="internal-link" target="_self" rel="noopener nofollow">herança</a> e <a data-tooltip-position="top" aria-label="Polimorfismo" data-href="Polimorfismo" href="fundamentos-de-linguagens-de-programação\av2\tipos-abstratos\polimorfismo\polimorfismo.html" class="internal-link" target="_self" rel="noopener nofollow">polimorfismo</a>
<br>Pode-se definir uma <a data-tooltip-position="top" aria-label="Classe" data-href="Classe" href="fundamentos-de-linguagens-de-programação\av2\tipos-abstratos\classes\classe.html" class="internal-link" target="_self" rel="noopener nofollow">classe</a> como uma descrição de um conceito abstrato
<br>A partir da descrição desse conceito, é possível gerar <a data-tooltip-position="top" aria-label="Objeto" data-href="Objeto" href="fundamentos-de-linguagens-de-programação\av2\tipos-abstratos\classes\objeto.html" class="internal-link" target="_self" rel="noopener nofollow">objetos</a> (instâncias de uma classe)
<br>A classe define o comportamento de seus objetos através de <a data-tooltip-position="top" aria-label="Método" data-href="Método" href="fundamentos-de-linguagens-de-programação\av2\tipos-abstratos\classes\método.html" class="internal-link" target="_self" rel="noopener nofollow">métodos</a>
<br>O estado dos objetos de uma classe é definido através dos <a data-tooltip-position="top" aria-label="Atributo" data-href="Atributo" href="fundamentos-de-linguagens-de-programação\av2\tipos-abstratos\classes\atributo.html" class="internal-link" target="_self" rel="noopener nofollow">atributos</a> dessa classe
]]></description><link>fundamentos-de-linguagens-de-programação\av2\tipos-abstratos\classes\classes-e-objetos.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Tipos Abstratos/Classes/Classes e Objetos.md</guid><pubDate>Fri, 28 Mar 2025 01:55:43 GMT</pubDate></item><item><title><![CDATA[Método]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av2\tipos-abstratos\classes\método.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Tipos Abstratos/Classes/Método.md</guid><pubDate>Fri, 28 Mar 2025 01:55:43 GMT</pubDate></item><item><title><![CDATA[Objeto]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av2\tipos-abstratos\classes\objeto.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Tipos Abstratos/Classes/Objeto.md</guid><pubDate>Fri, 28 Mar 2025 01:55:43 GMT</pubDate></item><item><title><![CDATA[Classes Abstratas]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av2\tipos-abstratos\herança\classes-abstratas.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Tipos Abstratos/Herança/Classes Abstratas.md</guid><pubDate>Fri, 28 Mar 2025 01:55:43 GMT</pubDate></item><item><title><![CDATA[Herança]]></title><description><![CDATA[ 
 <br>
<br>Fornece uma opção para o reuso de código e organização dos programas
<br>Ocorre quando um novo tipo abstrato de dados herda as funcionalidades de outro já existente
<br>O novo tipo pode alterar características do tipo herdado, adicionando novos valores e operações
<br>Uma classe que herda características de outra classe é chamada de classe derivada ou <a data-tooltip-position="top" aria-label="Subclasse" data-href="Subclasse" href="fundamentos-de-linguagens-de-programação\av2\tipos-abstratos\herança\subclasse.html" class="internal-link" target="_self" rel="noopener nofollow">subclasse</a>
<br>A classe que passa as características para uma subclasse é chamada de classe pai ou <a data-tooltip-position="top" aria-label="Superclasse" data-href="Superclasse" href="fundamentos-de-linguagens-de-programação\av2\tipos-abstratos\herança\superclasse.html" class="internal-link" target="_self" rel="noopener nofollow">superclasse</a>
<br>Uma subclasse pode diferir de sua superclasse de alguns modos:

<br>A superclasse pode definir alguns membros como tendo acesso privado
<br>A subclasse pode adicionar elementos inexistentes na superclasse
<br>A subclasse pode alterar um ou mais métodos herdados, gerando métodos sobrescritos


<br><br>
<br>Se uma nova classe é subclasse de apenas uma classe pai, diz-se que esse processo é uma herança simples
<br>Caso a nova classe tenha mais de uma classe pai, diz-se que o processo é uma herança múltipla
<br>Pode gerar alguns problemas:

<br>Duas superclasses com métodos com mesmo nome, porém implementações diferentes
<br>Organizações complexas
<br>Manutenção dificultada, devido às dependências mais complexas entre as classes


<br><br>
<br>Algumas vezes, o projeto de uma hierarquia resulta em classes que, devido à sua alta posição na hierarquia, não há sentido na existência de instâncias delas
<br>Nesse cenário, essas classes definem métodos de classe, mas não os implementam
<br>Um método não implementado é chamado de método abstrato
<br>Toda classe com pelo menos um método abstrato é chamada de classe abstrata
<br>Não é possível instanciar objetos de uma classe abstrata de forma direta
<br>Toda subclasse de uma classe abstrata deve fornecer implementações para os métodos abstratos herdados
<br>Exemplo:
<br>from abc import ABC, abstractmethod

class Animal(ABC):
	@abstractmethod
	def sound(self):
		pass

class Dog(Animal):
	def sound(self):
		return "Bark"

dog = Dog()
print(dog.sound())
Run]]></description><link>fundamentos-de-linguagens-de-programação\av2\tipos-abstratos\herança\herança.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Tipos Abstratos/Herança/Herança.md</guid><pubDate>Fri, 28 Mar 2025 01:55:43 GMT</pubDate></item><item><title><![CDATA[Herança Múltipla]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av2\tipos-abstratos\herança\herança-múltipla.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Tipos Abstratos/Herança/Herança Múltipla.md</guid><pubDate>Fri, 28 Mar 2025 01:55:43 GMT</pubDate></item><item><title><![CDATA[Subclasse]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av2\tipos-abstratos\herança\subclasse.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Tipos Abstratos/Herança/Subclasse.md</guid><pubDate>Fri, 28 Mar 2025 01:55:43 GMT</pubDate></item><item><title><![CDATA[Superclasse]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av2\tipos-abstratos\herança\superclasse.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Tipos Abstratos/Herança/Superclasse.md</guid><pubDate>Fri, 28 Mar 2025 01:55:43 GMT</pubDate></item><item><title><![CDATA[Polimorfismo]]></title><description><![CDATA[ 
 ]]></description><link>fundamentos-de-linguagens-de-programação\av2\tipos-abstratos\polimorfismo\polimorfismo.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Tipos Abstratos/Polimorfismo/Polimorfismo.md</guid><pubDate>Fri, 28 Mar 2025 01:55:43 GMT</pubDate></item><item><title><![CDATA[Tipos Abstratos de Dados e Orientação a Objetos]]></title><description><![CDATA[ 
 <br><br><br><br>]]></description><link>fundamentos-de-linguagens-de-programação\av2\tipos-abstratos\tipos-abstratos-de-dados-e-orientação-a-objetos.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/Tipos Abstratos/Tipos Abstratos de Dados e Orientação a Objetos.md</guid><pubDate>Fri, 28 Mar 2025 01:55:42 GMT</pubDate></item><item><title><![CDATA[AV2]]></title><description><![CDATA[ 
 <br><br><br><br><br><br><br>]]></description><link>fundamentos-de-linguagens-de-programação\av2\av2.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV2/AV2.md</guid><pubDate>Sun, 04 May 2025 17:55:16 GMT</pubDate></item><item><title><![CDATA[AV3]]></title><description><![CDATA[ 
 <br><br><br><br><br><br><br><br>]]></description><link>fundamentos-de-linguagens-de-programação\av3\av3.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/AV3/AV3.md</guid><pubDate>Thu, 15 May 2025 00:06:35 GMT</pubDate></item><item><title><![CDATA[Assuntos - Fundamentos de Linguagens de Programação]]></title><description><![CDATA[ 
 <br><br><br>]]></description><link>fundamentos-de-linguagens-de-programação\assuntos-fundamentos-de-linguagens-de-programação.html</link><guid isPermaLink="false">FUNDAMENTOS DE LINGUAGENS DE PROGRAMAÇÃO/Assuntos - Fundamentos de Linguagens de Programação.md</guid><pubDate>Tue, 13 May 2025 22:31:04 GMT</pubDate></item></channel></rss>